<{filename name=docs-cpgf-using-interface-api }>

<{autotoc}>

<{sgroup}>Using interface based API

<{sh}> What is interface based API
<{sc}>

<{autobr}>
The idea of interface based API is inspired by Windows Component Object Model.
All APIs are exposed in interface form, which is a cluster of abstract virtual functions.

<{/autobr}>	


<{sh}> Obtain meta service interface for reflection
<{sc}>

<{autobr}>
Include header file cpgf/gmetaapi.h, call createDefaultMetaService to create a default meta service.
<{piece}> IMetaService * createDefaultMetaService(); <{/piece}>

There two other functions related to the service.
<{piece}>
IMetaModule * getMetaModule();
IMetaService * createMetaService(IMetaModule * primaryModule);
<{/piece}>

getMetaModule returns a module.
A module is an executable, or a dynamic library.
An IMetaModule represents the meta information of current module.
Each module will have one and only one IMetaModule interface.

An IMetaService represents all meta information of the application, include the executable, any dynamic libraries.
An application should have one and only one IMetaService, no matter how many modules there are.

<{/autobr}>	



<{sh}> Obtain root interface for Lua binding
<{sc}>

<{autobr}>
Include header file cpgf/scriptbind/gluabind.h, call createLuaScriptObject to get an IScriptObject interface.

<{/autobr}>



<{sh}> Memory management in interface based API
<{sc}>

<{autobr}>
Very like Windows Component Object Model, cpgf interface based API utilizes reference count based memory management.
Two functions from the root interface IObject give the memory management,
<{piece}>
   virtual uint32_t G_API_CC addReference() = 0;
   virtual uint32_t G_API_CC releaseReference() = 0;
<{/piece}>

Note: interface returned by any API must be released (call releaseReference()).
The easiest way to hold an interface is to store it into a scoped pointer.
GScopedInterface (in gapi.h)

<{/autobr}>



<{sh}> Comparison of class-function based API and interface based API
<{sc}>

<table border="1" style="width:100%; text-align:left">
	<tr>
		<td style="text-align:center; width:30%">
			<b>Feature </b>
		</td>
		<td style="text-align:center; width:35%">
			<b>Class-function based API </b>
		</td>
		<td style="text-align:center; width:30%">
			<b>Interface based API </b>
		</td>
	<tr>
	
	<tr>
		<td> Binary compatible </td>
		<td> No </td>
		<td> Yes </td>
	<tr>
	
	<tr>
		<td> Memory management </td>
		<td> Raw memory management. Using new and delete. </td>
		<td> Reference count. Using addReference and releaseReference. </td>
	<tr>

	<tr>
		<td> Variant type in API </td>
		<td> GVariant </td>
		<td> GVariantData </td>
	<tr>

	<tr>
		<td> Meta type in API </td>
		<td> GMetaType </td>
		<td> GMetaTypeData </td>
	<tr>
	
	<tr>
		<td> Scoped pointer </td>
		<td> GScopedPointer (in gscopedptr.h) </td>
		<td> GScopedInterface (in gapi.h) </td>
	<tr>
	
	<tr>
		<td> Error handling </td>
		<td> Throw exception </td>
		<td> Error code </td>
	<tr>
	
	<tr>
		<td>  </td>
		<td>  </td>
		<td>  </td>
	<tr>
	
	<tr>
		<td>  </td>
		<td>  </td>
		<td>  </td>
	<tr>
	
</table>


<{/sgroup}>


<{/autotoc}>


<{include name="moredoc.txt" }>
