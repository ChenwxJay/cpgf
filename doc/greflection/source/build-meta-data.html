<html><head></head><body><div style="width:900px">

<h1>Build meta data</h1>

<h3>
1, Define meta class.
</h3>

<p>
Meta class represents a collection of meta information about a certain class.
All meta data in the class, like meta fields, meta properties, meta methods, meta enumerators, meta operators, are added to the meta class.
</p>

<p>
There are two ways to define the meta class, define the meta class inside the class declaration, or define the meta class outside of the class.
</p>

<table cols="3" border="1" cellpadding="5px" style="border-width:1px;border-style:groove;width:100%">
<tr style="text-align:center">
	<td></td>
	<td>Inside class declaration</td>
	<td>Outside class declaration</td>
</tr>

<tr>
	<td>Syntax</td>
	<td>
		<pre>
  class MyClass : public MyBaseClass {
  public:
    int getCRC(const std::string & s) const;

    // any other member definition here

  private:
    <b>gDefineMetaClass</b>(MyClass, MyBaseClass) {  
    	gReflectMethod(getCRC);

      // reflect any other data here
    }
  };
		</pre>
	</td>

	<td>
		<pre>
  class MyClass : public MyBaseClass {
  public:
    int getCRC(const std::string & s) const;

    // any other member definition here
  };

  <b>gDefineOffMetaClass</b>(MyClass, MyBaseClass) {  
  	gReflectMethod(getCRC);

    // reflect any other data here
  }
		</pre>
	</td>
</tr>
	
<tr>
	<td>Member visibility</td>
	<td>All members can be reflected. Public, protected, and private.</td>
	<td>Only public members can be reflected. If you hack the meta class to make the meta class a friend to your class, you can reflect anything.</td>
</tr>
	
<tr>
	<td>Source file to put in</td>
	<td>Must be put inside the class. So usually the meta data is put in header files.</td>
	<td>Can be any where. Ideally the data is put in the source file.</td>
</tr>

<tr>
	<td></td>
	<td></td>
	<td></td>
</tr>
</table>

<p>
There is very trivial difference between the two approaches. <br />
If you are designing your classes and meta system from scratch, use the inside class approach. <br />
If you are adding meta data to existing code and don't want to change the code, use the ourside class approach. <br />
If you really like one approach, just stick to it.
</p>


<h3>
2, Starting reflecting C++ elements.
</h3>

<table cols="3" border="1" cellpadding="5px" style="width:100%">
<tr>
	<td style="width:20%">Element</td>
	<td style="width:40%">What's this</td>
	<td style="width:40%">What can be done on the element</td>
</tr>

<tr>
	<td><b>Field</b></td>
	<td>A data member, or a global variable.</td>
	<td>
		<ul>
			<li>Examine the data type.</li>
			<li>Set or get the data value directly.</li>
		</ul>
	</td>
</tr>
<tr>
	<td>Reflect using function</td>
	<td colspan="2">
		<pre>
template &lt;typename FT&gt;
void reflectField(const std::string & name, FT field);
		</pre>
		Example:
		<pre>
reflectField("width", &MyClass:width);
		</pre>
	</td>
</tr>
<tr>
	<td>Reflect using macro</td>
	<td colspan="2">
		<pre>
gReflectField(field);
		</pre>
		Example:
		<pre>
gReflectField(width);
		</pre>
	</td>
</tr>

<tr><td colspan="3"></td></tr>

<tr>
	<td><b>Property</b></td>
	<td>A data member, or a global variable, with getter and setter functions optionally.</td>
	<td>
		<ul>
			<li>Examine the data type.</li>
			<li>Set or get the data value via getter and setter functions.</li>
			<li>If no getter or setter functions, the value can be set/got directly, like a field.</li>
			<li>Also can forbid getting or setting the propery. Read-only, write-only, or Can't-read-write.</li>
		</ul>
	</td>
</tr>
<tr>
	<td>Reflect using function</td>
	<td colspan="2">
		<pre>
template &lt;typename Getter, typename Setter&gt;
void reflectProperty(const std::string & name, const Getter & getter, const Setter & setter);
		</pre>
		Example:
		<pre>
reflectProperty("width", &MyClass::getWidth, &MyClass::setWidth);
		</pre>
	</td>
</tr>
<tr>
	<td>Reflect using macro</td>
	<td colspan="2">
		<pre>
gReflectGlobalProperty(prop, getter, setter)
		</pre>
		Example:
		<pre>
gReflectGlobalProperty(width, getWidth, setWidth)
		</pre>
	</td>
</tr>

<tr><td colspan="3"></td></tr>

<tr>
	<td><b>Method</b></td>
	<td>A member function or a global function. Can have arbitrary parameters and return value, and can be in any calling convention, such as cdecl and stdcall.</td>
	<td>
		<ul>
			<li>Examine function parameters and return value type.</li>
			<li>Invoke the function.</li>
		</ul>
	</td>
</tr>
<tr>
	<td>Reflect using function</td>
	<td colspan="2">
		<pre>
template &lt;typename FT&gt;
void reflectMethod(const std::string & name, FT func);
		</pre>
		Example:
		<pre>
reflectMethod("checkSum", &MyClass:checkSum);
		</pre>
	</td>
</tr>
<tr>
	<td>Reflect using macro</td>
	<td colspan="2">
		<pre>
gReflectMethod(method)
		</pre>
		Example:
		<pre>
gReflectMethod(checkSum)
		</pre>
	</td>
</tr>

<tr><td colspan="3"></td></tr>

<tr>
	<td><b>Constructor</b></td>
	<td>Object constructor function. Can have arbitrary parameters.</td>
	<td>
		<ul>
			<li>Examine constructor parameters.</li>
			<li>Invoke the constructor to create a new object.</li>
		</ul>
	</td>
</tr>
<tr>
	<td>Reflect using function</td>
	<td colspan="2">
		<pre>
template &lt;typename Signature&gt;
void reflectConstructor();
		</pre>
		Example:
		<pre>
reflectConstructor&lt;void *(int, const std::string &amp;)&gt;();
		</pre>
		Note: the return type must always be "void *", can't be any other type.
	</td>
</tr>
<tr>
	<td>Reflect using macro</td>
	<td colspan="2">
		<pre>
		</pre>
	</td>
</tr>

<tr><td colspan="3"></td></tr>

<tr>
	<td><b>Operator</b></td>
	<td>Any operator overloading, defined as class member, or global operator.</td>
	<td>
		<ul>
			<li>Examine operator parameters and return value type.</li>
			<li>Invoke the operator.</li>
		</ul>
	</td>
</tr>
<tr>
	<td>Reflect using function</td>
	<td colspan="2">
		<pre>
template &lt;typename Signature, typename Creator&gt;
void reflectOperator(const Creator & creator);
		</pre>
		Example:
		<pre>
		</pre>
	</td>
</tr>
<tr>
	<td>Reflect using macro</td>
	<td colspan="2">
		<pre>
		</pre>
	</td>
</tr>

<tr><td colspan="3"></td></tr>

<tr>
	<td><b>Class</b></td>
	<td>Any top level class, or inner class in nested class.</td>
	<td>
		<ul>
			<li>Examine the class type.</li>
			<li>Get any other reflection information in the class.</li>
		</ul>
	</td>
</tr>
<tr>
	<td>Reflect using function</td>
	<td colspan="2">
		<pre>
void reflectClass(const GMetaClass * metaClass);
		</pre>
		Example:
		<pre>
reflectClass(findMetaClass<MyClass>());
		</pre>
	</td>
</tr>
<tr>
	<td>Reflect using macro</td>
	<td colspan="2">
		<pre>
gReflectClass(cls)
		</pre>
		Example:
		<pre>
gReflectClass(MyClass)
		</pre>
	</td>
</tr>

<tr><td colspan="3"></td></tr>

<tr>
	<td><b>Annotation</b></td>
	<td>Any user customized annotation and comment.</td>
	<td>
		<ul>
			<li>Do what you want to do.</li>
		</ul>
	</td>
</tr>
<tr>
	<td>Reflect using function</td>
	<td colspan="2">
		<pre>
		</pre>
	</td>
</tr>
<tr>
	<td>Reflect using macro</td>
	<td colspan="2">
		<pre>
		</pre>
	</td>
</tr>

</table>

<h3>
2, Reflect fields.
</h3>

<p>
There are two ways to reflect fields.
</p>

<p>
2.1 Using function <b>reflectField</b> to reflect a field.
</p>

<pre>
template &lt;typename FT&gt;
void reflectField(const std::string & name, FT field);
</pre>

<p>
"name" is the field name. It may or may not be same as the field declaration name. <br />
"field" is the pointer to the field.
</p>

Some examples:
<pre>
// Reflect member data "width" in MyClass under the name "width"
reflectField("width", &MyClass::width);

// Reflect global data "application" in MyClass under the name "app"
reflectField("app", &application);
</pre>

<p>
2.2 Using macro <b>gReflectField</b> to reflect a field.
</p>

<pre>
gReflectField(width);
</pre>

<p>
This macro is the shortcut form of the function version. <br />
gReflectField(field) is exactly equals to reflectField("field", &MyClass::field); <br />
It accepts one parameter, the field name. It only needs the name, no the addressing symbol (&), no string quote mark (""). <br />
gReflectField will expose the field CurrentClass::width into current meta class, under the name "width".
</p>


<h3>
3, Reflect properties.
</h3>

<p>
There are two ways to reflect properties.
</p>

<p>
3.1 Using function <b>reflectProperty</b> to reflect a property.
</p>

<pre>
template <typename Getter, typename Setter>
void reflectProperty(const std::string & name, const Getter & getter, const Setter & setter);
</pre>

<p>
"name" is the field name. It may or may not be same as the field declaration name. <br />
"field" is the pointer to the field.
</p>

Some examples:
<pre>
// Reflect member data "width" in MyClass under the name "width"
reflectField("width", &MyClass::width);

// Reflect global data "application" in MyClass under the name "app"
reflectField("app", &application);
</pre>

<p>
3.2 Using macro <b>gReflectField</b> to reflect a field.
</p>

<pre>
gReflectField(width);
</pre>

<p>
This macro is the shortcut form of the function version. <br />
gReflectField(field) is exactly equals to reflectField("field", &MyClass::field); <br />
It accepts one parameter, the field name. It only needs the name, no the addressing symbol (&), no string quote mark (""). <br />
gReflectField will expose the field CurrentClass::width into current meta class, under the name "width".
</p>


<h3>
3, Reflect methods.
</h3>

<p>
There are two ways to reflect a methods.
</p>

<p>
3.1 Using function <b>reflectMethod</b> to reflect method.
</p>

<pre>
template &lt;typename FT&gt;
void reflectMethod(const std::string & name, FT func);
</pre>

<p>
3.2 Using macro <b>gReflectField</b> to reflect a method.
</p>

<pre>
gReflectMethod(sum);
</pre>

<p>
gReflectMethod accepts one parameter, the function name. It only needs the name, no the addressing symbol (&), no string quote mark (""). <br />
gReflectMethod will expose the method CurrentClass::sum into current meta class, under the name "sum".
</p>




</div></body></html>
