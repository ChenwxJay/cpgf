<{filename name=docs-cpgf-gvariant }>

<{title}>cpgf library -- Using GVariant<{/title}>

<{autotoc}>

<{sgroup}>Using GVariant

<{sh}> Overview
<{sc}>

<{autobr}>
The idea of GVariant is inspired by the similar Variant in Windows COM technology.
A GVariant is used to represent arbitrary type of value.
Any value, such as but not limited to, integer, float, pointer, object, reference, can be stored in a GVariant.

The reflection and script binding libraries use GVariant extensively. GVariant is the very core concept in those libraries.

Please bear in mind, GVariant is used in runtime, so it doesn't remember any compile time information, except the fundamental types.
So GVariant is not 100% type safe. To use it correctly, you must know the type it holds.

Also, GVariant is not only for reflection. It's an all purpose variant data type.

<{/autobr}>


<{sh}> Store value to GVariant
<{sc}>

<{autobr}>
Any values can be converted to a GVariant implicitly, so you don't need to call GVariant constructor explicitly.

This is why the invoke function in GMetaMethod accepts only GVariant but any value can be passed directly.
The prototype of "invoke" in GMetaMethod is,
GVariant invoke(void * instance, const GVariant & p1, const GVariant & p2, ..., const GVariant & pN);
We can call it as method->invoke(instance, 5, "test", myObject).
<{/autobr}>


<{sh}> Retrieve value from GVariant
<{sc}>

<{autobr}>
A GVariant can be converted back to a normal value with the function fromVariant.

Assume v is a GVariant.

<{piece}> int n = fromVariant<int>(v); <{/piece}>
Convert v to integer.

<{piece}> string s = fromVariant<char *>(v); <{/piece}>
Convert v to C string then assign to a STL string.

<{piece}> MyObject obj = fromVariant<MyObject>(v); <{/piece}>
Convert v to MyObject.

If fromVariant finds the GVariant can't be converted to the desired type, an exception GVariantException will be thrown.

To test if a GVariant can be converted to a type, use canFromVariant.
It has the same parameters as fromVariant, but returns a boolean to indicate if the GVariant can be casted.

<{/autobr}>


<{sh}> Store non-copyable object or reference to GVariant
<{sc}>

<{autobr}>
Bye default, GVariant requires the value assigned to it copyable.
If the value is a class object, but the copy constructor is private or not implemented, when trying to create GVariant from such value, compiling will fail.
To store non-copyable object or reference to GVariant, use function createVariant.

<{piece}>
template <bool CanShadow, typename T>
GVariant createVariant(const T & value, bool allowShadow = false);
<{/piece}>

The first template parameter, CanShadow, determines if the object copyable.
If CanShadow is false, the object is not copyable.

So to store a non-copyable object, named A, to GVariant v, write like this,
GVariant v = createVariant<false>(A);
<{/autobr}>


<{sh}> Rules to cast from GVariant
<{sc}>

<{autobr}>
Rule 1, A GVariant with fundamental value can be casted to any other fundamental.

<{piece}>
GVariant v;
v = 1; // integer
fromVariant<double>(v); // OK
<{/piece}>

Rule 2, A GVariant with pointer value can be casted to any other pointer, even if the pointer dimension is different.

<{piece}>
v = (char *)1;
fromVariant<int **>(v); // OK
<{/piece}>

Rule 3, A GVariant with fundamental value or pointer value can be casted to an object that has constructor to accept the type implicitly.

<{piece}>
v = "abc"; // C string, const char *
std::string s = fromVariant<std::string>(v); // OK, because std::string accepts "const char *".
<{/piece}>

Rule 4, When casting a GVariant with object (T) or object reference (T &) to another object type (U), T and U must be the same type.
Otherwise, the memory may be corrupted.
This is because of GVariant doesn't remember any type information, except the fundamental types.
So when casting to type U, GVariant will always assume that it holds a buffer with sizeof(U) and try to cast the buffer to U.

Rule 5, <b>warning</b>, By default, casting a GVariant to reference-to-const (const T &) will always cause the object be copied even if it's not necessary.

<{piece}>
std::string s = "blah";
v = s;
const std::string & rs = fromVariant<const std::string &>(v);
<{/piece}>

rs will hold a temporary copy of "blah", it doesn't reference to s.
The address of rs and v will be different. &rs != &v

This means, when calling a meta method which has reference to const parameter, the value passed to it will be copied.

Why do we need this kind of default behavior to copy the object instead of just reference it?
This is to simulate the nature C++ behavior. Unlike a normal reference (T &), a reference to const is special because it allows the compiler to generate temporary object for it.
For example, if we have the code,
const std::string & rs = "abc";
A temporary object of std::string will be created and rs will reference to it.
And also for most situation the compiler will not need to create the temporary object, just let the reference happen.
<{piece}>
std::string s = "abc";
const std::string & rs = s; // no temporary object.
<{/piece}>

We want to simulate the behavior in GVariant, however, we can't have the temporary object, only compiler knows how to create/destroy it, also we can't determine when to create the temporary when not.
So what we can do is just let GVariant copy the object, no matter it's necessary or not.

However fortunately, GVariant provides a mechanism to change the default behavior.
fromVariant has a second boolean template parameter, which is false by default. If it's true, casting to reference to const will cause a reference, not a copy.
<{piece}>
std::string s = "blah";
v = s;
const std::string & rs = fromVariant<const std::string &, true>(v);
<{/piece}>

rs will become a reference to v.
The address of rs and v will be the same. &rs == &v

<{/autobr}>


<{/sgroup}>

<{/autotoc}>


<{include name="moredoc.inc" }>

