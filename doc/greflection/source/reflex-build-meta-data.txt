url: docs-cpgf-reflection-build-meta-data

<h3>ABC</h3>

<{autotoc}>

<{sgroup}>Define meta classes

<{sh}> Overview
<{sc}>
	<p>
<{autobr}>	
	Meta class represents a collection of meta information about a certain class.
	All meta data, like meta fields, meta properties, meta methods, meta enumerators, meta operators, meta constructor, meta annotation, must be added to a meta class.
	For global fields and methods, they must be added to the global meta class (get via function getGlobalMetaClass).
	In other words, Reflex is class based reflection system.

	<b>Buiding meta data using function and macro helpers</b>
	Most meta data can be built in two ways,
	Using function -- give you best control over the data type, name, etc. All reflex functions are prefixed with "reflect". For instance, reflectField.
	Using macro helper -- shortcut macro to save typing. All reflex macros start with GMETA_. For instance, GMETA_FIELD.
<{/autobr}>
	</p>

<{sh}> Define meta classes outside of the classes declaration.
<{sc}>
	Assume we want to define meta classes for below classes

<{code}>
	class Animal
	{
	};

	class Cat : public Animal
	{
	};
<{/code}>

	<p>Now let's build meta class for Animal.</p>

<{code}>
	GMETA_DEFINE_CLASS(Animal, Animal, "Animal")
	{
		// add any meta data here to reflect fields, methods, etc.
	}
<{/code}>

	<p>
	Use macro GMETA_DEFINE_CLASS to define a meta class.
	GMETA_DEFINE_CLASS accepts three primary parameters, plus arbitrary number of varadic parameters.
	</p>
	<p><i>The first parameter, here is Animal</i>, is the class type. It can have any scope prefix, such as MyNameSpace::Animal.</p>
	<p><i>The second parameter, here is Animal again</i>, is the class type alias. It can be any legal C++ symbol, as long as it's unique in the program. It can't have any scrop prefix. That's to say, it can't contain any '::'.</p>
	<p><i>The third parameter, here is "Animal"</i>, is the name of the meta class. It can be any string, such as "Meta::WhatNameSpace::Animal", but highly recommand that only C++ symbol and ':' or '.' be used. It must be unique in the meta system. It's the key to find the meta class.</p>
	
	<p>Now let's build meta class for Cat.</p>

<{code}>
	GMETA_DEFINE_CLASS(Cat, Cat, "Cat", Animal)
	{
		// add any meta data here to reflect fields, methods, etc.

		reflectField("eyes", &Cat::eyes);
	}
<{/code}>
	<p>
<{autobr}>
	This time there is the fourth parameter, Animal, which is the base class, aka, super class.
	Reflex supports multiple inheritance. If Cat is also dervied from Biological, just add Biological to GMETA_DEFINE_CLASS.
	
	The base classes are not necessary reflected. When a non-reflected base class is retrieving for meta class by calling GMetaClass::getBaseClass, it always return NULL. However, calling GMetaClass::getBaseCount to get base class count will include all non-reflected base classes.
<{/autobr}>
	</p>



<{sh}> Add meta data to global scope
<{sc}>
<{code}>
	GMETA_DEFINE_GLOBAL()
	{
		// add any meta data here to reflect fields, methods, etc.

		reflectField("catCount", &catCount);
	}
<{/code}>

<{autobr}>
	Macro "GMETA_DEFINE_GLOBAL" indicates that any reflection between the curve brackets are reflected to global scope.
	The global scoped is treated as a meta class, but it contains all global meta data for globa variables, methods, classes, etc.

	When any meta class is defined by GMETA_DEFINE_CLASS, it's add to global scope automatically.
<{/autobr}>	


<{sh}> Reflect templates
<{sc}>
<{code}>
	template <typename T>
	class TestBase
	{
	public:
		virtual ~TestBase();

		int getDouble() const;
	};

	template <typename T, typename P>
	class TestObject : public TestBase<T>
	{
	public:
		int getSize() const;
	};

	GMETA_DEFINE_TEMPLATE(
			TestObject,  // 1
			TestObject,  // 2
			typename T GPP_COMMA() typename P,  // 3
			T GPP_COMMA() P,  // 4
			"",  // 5
			TestBase<T> ) {  // 6

		using namespace cpgf;

		GMETA_METHOD(getSize);
		GMETA_METHOD(getDouble);
	}

	GMETA_INSTANTIATE_TEMPLATE("template::TestObject_char_int", TestObject, char GPP_COMMA() int);
<{/code}>

<{autobr}>
	C++ template can be reflected. And they are reflected as template, rather than class.
	That's to say, the template can be reflected once, then instantiate instance for each certain type parameter.
	
	Using macro "GMETA_DEFINE_TEMPLATE" to reflect template.
	Like reflecting class, the first two parameters are the class type and the class type alias. Here indeed it's the template "type".
	The third parameter is the type parameters. It's the parameters that passed in template<>.
	Note the GPP_COMMA(), it's expanded to ",", but we can't use "," directly here.
	The fourth parameter is the parameter, without the "typename".
	The fifth paramter is the name, it can be empty here.
	The sixth and other paramters are the base classes.
	
	Like C++ template, a reflected template can't be used until it's instantiated.
	Using macro GMETA_INSTANTIATE_TEMPLATE to instantiate a template.
	The first parameter is the instance name. It's same as class name in reflected class. It must be unique.
	The second parameter is the template alias. It must be same as the second parameter in GMETA_DEFINE_TEMPLATE.
	The thid parameter, is the real type parameter.
	
	Above instantiate a meta class which is TestObject<char, int>.
<{/autobr}>


<{sh}> Reflect classes inside of the classes declaration.
<{sc}>
<{autobr}>
	It's possible to reflect class just inside of the class declaration in the header file. That's also known as intrusive reflection.
	However, I won't give any document here, because I'm really hesitating whether to remove this feature.
	
	So unless there are good reasons, most likely in the future version, classes won't be reflected inside the class declaration.
<{/autobr}>


<{/sgroup}>


<{sgroup}>Build meta data

<{sh}> Overview
<{sc}>
	<p>
<{autobr}>	
	All meta data must be put into some meta class definition blocks.
<{/autobr}>	
	</p>

<{/sgroup}>



<{sh}> Reflect field
<{sgroup indent="1"}>

<{sh}> What's field
<{sc}>
	<p>
<{autobr}>
	A field is either a member data or a global variable.
	Getting and setting a field will be applied directly to the field without any setter or getter function.
	To use setter and getter functions, use Property.
<{/autobr}>
	</p>

<{sh}> Using function
<{sc}>
<{code}>
	class TestObject
	{
	private:
		int width;
		std::string name;
		TestData data;

		GMETA_FRIEND(TestObject);
	}

	GMETA_DEFINE_CLASS(blah blah)
	{
		reflectField("width", &TestObject::width);
		reflectField("data", &TestObject::data, GMetaPolicyNoncopyable());
	}
<{/code}>

<p>
<{autobr}>
	reflectField takes two or three parameters.
	The first parameter is the name. The named is used to find the meta data later.
	The second parameter is the field address.
	The third parameter is optional. It's the policy.

	GMETA_FRIEND is used to make the reflection friend to TestObject so it can access private member in TestObject.
	If the member are public, no need GMETA_FRIEND.
<{/autobr}>
</p>

<{sh}> Using macro helper
<{sc}>
<{code}>
	class TestObject
	{
	private:
		int width;
		std::string name;
		TestData data;

		GMETA_FRIEND(TestObject);
	}

	GMETA_DEFINE_CLASS(blah blah)
	{
		GMETA_FIELD(width);
	}
<{/code}>

<p>
<{autobr}>
	GMETA_FIELD takes only one parameter.
	The macro will use the parameter as the name and address.
	Policy can't be passed in to the macro.
<{/autobr}>
</p>

<{/sgroup}>



<{sh}> Reflect property
<{sgroup indent="1"}>

<{sh}> What's property
<{sc}>
	<p>
<{autobr}>
	A property is just a member data or a global variable, but can be accessed with or without getter or setter functions.
<{/autobr}>
	</p>

<{sh}> Using function
<{sc}>
<{code}>
	class TestObject
	{
	public:
		int getWidth() const;
		void setWidth(int width);
	
		const std::string & getName() const;
	
	public:
		int height;

	private:
		int width;
		std::string name;
	}

	GMETA_DEFINE_CLASS(blah blah)
	{
		reflectProperty("name", &TestObject::getName, 0); // #1
		reflectProperty("width", &TestObject::getWidth, &TestObject::setWidth); // #2
		reflectProperty("height", &height, &height, GMetaPolicyNoncopyable()); // #3
	}
<{/code}>

<p>
<{autobr}>
	reflectProperty takes three or four parameters.
	The first parameter is the name. The named is used to find the meta data later.
	The second parameter is getter address.
	The third parameter is setter address.
	The fourth parameter is optional. It's the policy.

	Here "getter" and "setter" are not necessary functions, they can be the data address directly.
<{/autobr}>
</p>

<{sh}> Using macro helper
<{sc}>
<{code}>
	class TestObject
	{
	public:
		int getWidth() const;
		void setWidth(int width);
	
		SomeData & getData() const;
	
	public:
		int height;
		SomeData data;

	private:
		int width;
	}

	GMETA_DEFINE_CLASS(blah blah)
	{
		GMETA_PROPERTY(width, getWidth, setWidth);
		GMETA_PROPERTY(data, getData, data);
	}
<{/code}>

<p>
<{autobr}>
	GMETA_PROPERTY takes three parameter. Name, getter, then setter.
	Policy can't be passed in to the macro.
<{/autobr}>
</p>

<{/sgroup}>



<{sh}> Reflect method
<{sgroup indent="1"}>

<{sh}> What's method
<{sc}>
	<p>
<{autobr}>
	A method is a function.
	It can take any parameters. If any parameter is an object, that object is not necessary to be reflected.
	It can be any function, such as member function, virtual function, static member function, global function.
	It can also has any calling convention, such as cdecl, stdcall, fastcall.
	For member function, it can be const, volatile, and const volatile.
<{/autobr}>
	</p>

<{sh}> Using function
<{sc}>
<{code}>
	class TestObject
	{
	public:
		int getWidth() const;
	}

	GMETA_DEFINE_CLASS(blah blah)
	{
		reflectMethod("getWidth", &TestObject::getWidth);
	}
<{/code}>

<p>
<{autobr}>
	reflectMethod takes two or three parameters.
	The first parameter is the name. The named is used to find the meta data later.
	The second parameter is method address.
	The third parameter is optional. It's the policy.
<{/autobr}>
</p>

<{sh}> Using macro helper
<{sc}>
<{code}>
	class TestObject
	{
	public:
		int getWidth() const;
	}

	GMETA_DEFINE_CLASS(blah blah)
	{
		GMETA_METHOD(getWidth);
	}
<{/code}>

<p>
<{autobr}>
	GMETA_METHOD takes one parameter, the name.
	Policy can't be passed in to the macro.
<{/autobr}>
</p>

<{/sgroup}>



<{sh}> Reflect constructor
<{sgroup indent="1"}>

<{sh}> What's constructor
<{sc}>
	<p>
<{autobr}>
	A constructor is a C++ class constructor.
	It can take any parameters, same as method.
<{/autobr}>
	</p>

<{sh}> Using function
<{sc}>
<{code}>
	class TestObject
	{
	public:
		TestObject();
		TestObject(int width);
		TestObject(int width, const std::string & name);
		TestObject(int width, const std::string & name, const TestData & data);
	}

	GMETA_DEFINE_CLASS(blah blah)
	{
		reflectConstructor<void * ()>();
		reflectConstructor<void * (int)>();
		reflectConstructor<void * (int, const std::string &)>();
		reflectConstructor<void * (int, const std::string &, const TestData &)>();
	}
<{/code}>

<p>
<{autobr}>
	reflectConstructor is a template function.
	It accepts one template parameter, and one optional policy function parameter.
	The template parameter is the function type. The function type must always return void *.
<{/autobr}>
</p>

<{sh}> Using macro helper
<{sc}>
<p>
<{autobr}>
	No macro helper available for constructor.
<{/autobr}>
</p>

<{/sgroup}>




<{sh}> Reflect operator
<{sgroup indent="1"}>

<{sh}> What's operator
<{sc}>
	<p>
<{autobr}>
	An operator is a C++ class operator that be overloaded.
	It can take any parameters, same as method.
<{/autobr}>
	</p>

<{sh}> Using function
<{sc}>
<{code}>
	class TestObject
	{
	public:
		TestObject operator + (int n) const; // a + b
		TestObject & operator &= (int n); // a &= b
		TestObject operator ++ (int); // a++
		int operator ->* (int TestObject::* p); // a->*b
		int operator () (const std::string & s, int n) const; // a(s, n)
	}
	TestObject operator + (int n, const TestObject & obj);

	GMETA_DEFINE_CLASS(blah blah)
	{
		reflectOperator<TestObject (const GMetaSelf &, int)>(mopHolder + mopHolder); // member operator +
		reflectOperator<TestObject (int, const TestObject &)>(mopHolder + mopHolder); // global operator +
		reflectOperator<TestObject & (GMetaSelf, int)>(mopHolder &= mopHolder); // member operator &=
		reflectOperator<TestObject (GMetaSelf)> (mopHolder++); // member operator ++
		reflectOperator<int (GMetaSelf, int TestObject::*)>(mopHolder->*mopHolder); // member operator ->*
		reflectOperator<int (const std::string &, int)>(mopHolder(mopHolder)); // member operator (const std::string &, int)
	}
<{/code}>

<p>
<{autobr}>
	reflectOperator is a template function.
	It accepts one template parameter, one operator function parameter, and one optional policy function parameter.
	The template parameter is the operator function type.
	The first function parameter is the result to apply the same operator on mopHolder.
	For example, if it's operator +, then the parameter is (mopHolder + mopHolder)
	For most operators, it's quite intuitive.
	Here are some operators that are not that intuitive:
	Type conversion, such like "int()", etc. The parameter is mopHolder().
	Functor, such like "void (int)". The parameter is mopHolder(mopHolder);

	About GMetaSelf. GMetaSelf indicates that parameter is the object itself. So that parameter can be passed as both object reference and object pointer.
<{/autobr}>
</p>

<{sh}> Using macro helper
<{sc}>
<p>
<{autobr}>
	No macro helper available for operator.
<{/autobr}>
</p>

<{/sgroup}>





<{sh}> Reflect annotation
<{sgroup indent="1"}>

<{sh}> What's annotation
<{sc}>
	<p>
<{autobr}>
	An annotation is a kind of special meta data that's added by programmer rather than code.
	All other non-annotation meta data, such as class, method, field, property, constructor, operator, can have annotations.
<{/autobr}>
	</p>

<{sh}> Using function
<{sc}>
<{code}>
	GMETA_DEFINE_CLASS(blah blah)
	{
		reflectAnnotation("attribute")
			("name", "What's the name")
			("count", 3)
			("data", TestData("blahblah", 5))
		;
		flushAnnotation();

		reflectAnnotation("style")
			("name", L"WindowStyle")
			("cat", mcatEnum)
			("dog", TestData(mcatEnum, "WindowStyle"))
		;
		reflectAnnotation("size")
			("name", "TheSize")
		;
		GMETA_ENUM(WindowStyle, CLASS::ws0, CLASS::ws1, CLASS::ws2, CLASS::ws3);
	}
<{/code}>

<p>
<{autobr}>
	reflectAnnotation takes one parameter, the annotation name. And then return an object, which can be used to add more values to the annotation.
	To add values, just call the functor operator on the object. The first parameter is the value name, the second parameter is the value.
	
	An annotation is always added to next non-annotation meta data. To add the annotation to the class itself, call flushAnnotation().
	
	In above code, the annotation "attribute" is added to the meta class, and the annotation "style" and "size" are added to meta enum "WindowStyle".
<{/autobr}>
</p>

<{sh}> Using macro helper
<{sc}>
<p>
<{autobr}>
	No macro helper available for annotation.
<{/autobr}>
</p>

<{/sgroup}>





<{sh}> Reflect enumerators
<{sgroup indent="1"}>

<{sh}> What's enumerator
<{sc}>
	<p>
<{autobr}>
<{/autobr}>
	</p>

<{sh}> Using function
<{sc}>
<{code}>
	GMETA_DEFINE_CLASS(blah blah)
	{
		reflectEnum<CLASS::EnumSecond>("EnumSecond")
			("bs1", CLASS::bs1)
			("bs2", CLASS::bs2)
			("bs3", CLASS::bs3)
			("bs4", CLASS::bs4)
			("bs5", CLASS::bs5)
	;
	}
<{/code}>

<p>
<{autobr}>
<{/autobr}>
</p>

<{sh}> Using macro helper
<{sc}>
<{code}>
	GMETA_DEFINE_CLASS(blah blah)
	{
		GMETA_ENUM(EnumFirst, CLASS::ws1, CLASS::ws2, CLASS::ws3, CLASS::ws4);
	;
	}
<{/code}>
<p>
<{autobr}>
<{/autobr}>
</p>

<{/sgroup}>






<{sh}> Reflect nested classes
<{sgroup indent="1"}>

<{sh}> What's nested classes
<{sc}>
	<p>
<{autobr}>
<{/autobr}>
	</p>

<{sh}> Using function
<{sc}>
<{code}>
<{/code}>

<p>
<{autobr}>
<{/autobr}>
</p>

<{sh}> Using macro helper
<{sc}>
<{code}>
	GMETA_CLASS(TestOutterClass::Inner);
	GMETA_CLASS(TestOutterClass::AnotherInner);
<{/code}>
<p>
<{autobr}>
<{/autobr}>
</p>

<{/sgroup}>




<{/autotoc}>


