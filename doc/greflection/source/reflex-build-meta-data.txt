<{filename name=docs-cpgf-reflection-build-meta-data }>

<{title}>cpgf reflection -- building meta data<{/title}>

<{include name="cpgf-header.inc" }>

<{autotoc}>

<{sgroup}>Overview

<{autobr}>
Below is a piece of sample code to define all kind of meta data.
The full compilable code can be found in file samples/reflection/overview.cpp 
<{/autobr}>	

<{code}>

void myMetaBuild()
{
	using namespace cpgf;

	// define meta class
	GDefineMetaClass<MyClass, MyFirstBaseClass, MySecondBaseClass> // which class to define (MyClass), and give the base classes
		::define("MyClass_TheNameCanBeDiffWithClassName") // the class name

		// The meta class for MyClass has two annotations.
		// First's name is attribute, and has three elements.
		// Second's name is style.
		._annotation("attribute")
			._element("name", "What's my name") // element name, value is an Ansi string
			._element("cat", mcatClass) // element cat, value is int
			._element("dog", TestData(mcatClass, "A cute dog")) // element dog, value is TestData
		._annotation("style")
			._element("fit", L"fit me") // element fit, value is a Wide string.

	    // constructors
		._constructor<void * ()>()
		._constructor<void * (int)>()
		._constructor<void * (int, const std::string &)>(GMetaPolicyCopyAllConstReference())

		._field("width", &MyClass::width) // reflect a normal field
		._field("nocopy", &MyClass::nocopy, GMetaPolicyNoncopyable()) // reflect a field with policy

		._property("name", &MyClass::getName, 0) // a property has only getter, no setter
		._property("data", &MyClass::getData, &MyClass::data) // a property has both getter and setter.
		// also can reflect a property with policy
		
		._method("getWidth", &MyClass::getWidth) // reflect a normal method
		._method("incWidth", &MyClass::incWidth, GMetaPolicyCopyAllConstReference()) // reflect a method with policy
			._annotation("attr") // the method incWidth has an annotation
				._element("what", "ok")

		// operator
		._operator<MyClass (const GMetaSelf &, int)>(mopHolder + mopHolder)

		// enumerator
		._enum<MyClass::WindowStyle>("WindowStyle")
			._element("ws0", MyClass::ws0)
			._element("ws1", MyClass::ws1)
			._element("ws2", MyClass::ws2)
			._element("ws3", MyClass::ws3)

		// nested class
		._class(
			GDefineMetaClass<MyClass::AnotherInner>
				::create("AnotherInner")
				._field("y", &MyClass::AnotherInner::y)
		)
	;

	// define global meta data

	GDefineMetaGlobal()
		._field("myStats", &myStats)
		._method("myAddNumber", &myAddNumber)
	;

	// define meta data for template
	GDefineMetaClass<MyTemplate<char, int> >::lazy("MyTemplate_char_int", &lazyDefineClass<MyTemplate<char, int> >);
}

int main()
{
	myMetaBuild();

	// now meta data is ready to use

	return 0;
}
<{/code}>


<{/sgroup}>



<{sgroup}>Define meta classes

<{sh}> Overview
<{sc}>
	<p>
<{autobr}>	
	Meta class represents a collection of meta information about a certain class.
	All meta data, like meta fields, meta properties, meta methods, meta enumerators, meta operators, meta constructor, meta annotation, must be added to a meta class.
	For global fields and methods, they must be added to the global meta class.
	In other words, this library is class based reflection system.
	
	To build the meta data, include the header file gmetadefine.h.

	<b>Buiding meta data using only functions.</b>
	From version 1.2.0, meta data can be built using only chained functions.
	The ugly macros in previous version had gone.
<{/autobr}>
	</p>

<{sh}> Define a meta class.
<{sc}>
	Assume we want to define meta classes for below classes

<{code}>
	class Animal
	{
	};

	class Cat : public Animal
	{
	};
<{/code}>

	<p>Now let's build meta class for Animal.</p>

<{code}>
	<b>GDefineMetaClass</b><Animal>
		::<b>define</b>("Animal")
		._field(blah blah)
		._method(blah blah)
	;
<{/code}>

	<{autobr}>
	GDefineMetaClass is the template to define a meta class.
	It accepts one or more template parameters.
	The first template parameter is always the class itself. The other template parameters are the class' super classes (aka, parent classes).

	The function "define" is used to define a top level class.
	Top level class means the class is in the global or a namespace scope. It's not nested in another class.
	<{/autobr}>

	<p>Now let's build meta class for Cat.</p>

<{code}>
	<b>GDefineMetaClass</b><Cat, Animal>
		::<b>define</b>("Cat")
		._field(blah blah)
		._method(blah blah)
	;
<{/code}>
	<p>
<{autobr}>
	This time there is the second template parameter, Animal, which is the base class, aka, super class.
	The library supports multiple inheritance. If Cat is also derived from Biological, just add Biological to GDefineMetaClass.
	
	The base classes are not necessary reflected. When a non-reflected base class is retrieving for meta class by calling GMetaClass::getBaseClass, it always return NULL. However, calling GMetaClass::getBaseCount to get base class count will include all non-reflected base classes.

	GDefineMetaClass::<b>create</b>
	The function "create" behaves similar as "define". "define" will add the meta class to global scope, while "create" not.
<{/autobr}>
	</p>


<{sh}> Lazy define a meta class
<{sc}>
<{code}>
	void lazyDefineClass(GDefineMetaClass<Animal> define)
	{
		define
			._field(blah blah)
			._method(blah blah)
		;
	}

	GDefineMetaClass<Animal>::<b>lazy</b>("Animal", &lazyDefineClass);
<{/code}>
	<p>
<{autobr}>
	GDefineMetaClass::define will cause all meta data is built immediately.
	GDefineMetaClass::lazy will delay the building until the meta data is really used.
	"lazy" is similar with "define", except it requires a second parameter, which is a function that does the real reflecting.
	The function prototype is
	void func(GDefineMetaClass<T> define)
	Which T is the class to build for, here is Animal.

	GDefineMetaClass::<b>lazyCreate</b> "create" a meta class with lazy build.
<{/autobr}>
	</p>

<{sh}> Add meta data to global scope
<{sc}>
<{code}>
	<b>GDefineMetaGlobal</b>()
		._field(blah blah)
		._method(blah blah)
	;

<{/code}>

<{autobr}>
	GDefineMetaGlobal indicates that any reflection added to it are reflected to global scope.
	The global scoped is treated as a meta class, but it contains all global meta data for global variables, methods, classes, etc.

	When any meta class is defined by GDefineMetaClass::define, it's add to global scope automatically.
<{/autobr}>	


<{sh}> Reflect templates
<{sc}>
<{code}>
	template <typename T>
	class MyTemplateBase
	{
	public:
		virtual ~MyTemplateBase();

		int getDouble() const;
	};

	template <typename T, typename P>
	class MyTemplate : public MyTemplateBase<T>
	{
	public:
		int getSize() const;
	};

	template <typename ClassType>
	void lazyDefineClass(cpgf::GDefineMetaClass<ClassType> define)
	{
		define
			._method("getSize", &ClassType::getSize)
			._method("getDouble", &ClassType::getDouble)
		;
	}

	// instantiation
	GDefineMetaClass<MyTemplate<char, int> >::lazy("MyTemplate_char_int", &lazyDefineClass<MyTemplate<char, int> >);
	// another instantiation
	GDefineMetaClass<MyTemplate<double, short> >::lazy("MyTemplate_double_short", &lazyDefineClass<MyTemplate<double, short> >);
<{/code}>

<{autobr}>
Though we can treat a template instantiation as a normal class and use GDefineMetaClass<T>::define to reflect the meta data, it will be better to use the "lazy" trick in the above sample code.
Then the lazy define function (here is lazyDefineClass) can be reused for every template instantiations.
Note unlike lazy reflection class which lazy function is a normal function, the lazy function for template is a template function.
<{/autobr}>


<{/sgroup}>


<{sgroup}>Build meta data


<{sh}> Reflect field
<{sgroup indent="1"}>

<{sh}> What's field
<{sc}>
	<p>
<{autobr}>
	A field is either a member data or a global variable.
	Getting and setting a field will be applied directly to the field without any setter or getter function.
	To use setter and getter functions, use Property.
<{/autobr}>
	</p>

<{code}>
	GDefineMetaClass<MyClass>
		::define("MyClass")

		.<b>_field</b>("width", &MyClass::width) // reflect a normal field
		.<b>_field</b>("nocopy", &MyClass::nocopy, GMetaPolicyNoncopyable()) // reflect a field with policy
<{/code}>

<p>
<{autobr}>
	_field takes two or three parameters.
	The first parameter is the name. The named is used to find the meta data later.
	The second parameter is the field address.
	The third parameter is optional. It's the policy.
<{/autobr}>
</p>

<{/sgroup}>



<{sh}> Reflect property
<{sgroup indent="1"}>

<{sh}> What's property
<{sc}>
	<p>
<{autobr}>
	A property is just a member data or a global variable, but can be accessed with or without getter or setter functions.
<{/autobr}>
	</p>

<{code}>
	GDefineMetaClass<MyClass>
		::define("MyClass")

		._property("name", &MyClass::getName, 0) // a property has only getter, no setter
		._property("data", &MyClass::getData, &MyClass::data, MyPolicy()) // a property has both getter and setter, and has a policy.
<{/code}>

<p>
<{autobr}>
	._property takes three or four parameters.
	The first parameter is the name. The named is used to find the meta data later.
	The second parameter is getter address.
	The third parameter is setter address.
	The fourth parameter is optional. It's the policy.

	Here "getter" and "setter" are not necessary functions, they can be the data address directly.
<{/autobr}>
</p>

<{/sgroup}>



<{sh}> Reflect method
<{sgroup indent="1"}>

<{sh}> What's method
<{sc}>
	<p>
<{autobr}>
	A method is a function.
	It can take any parameters. If any parameter is an object, that object is not necessary to be reflected.
	It can be any function, such as member function, virtual function, static member function, global function.
	It can also has any calling convention, such as cdecl, stdcall, fastcall.
	For member function, it can be const, volatile, and const volatile.
<{/autobr}>
	</p>

<{code}>
	GDefineMetaClass<MyClass>
		::define("MyClass")

		._method("getWidth", &MyClass::getWidth) // reflect a normal method
		._method("incWidth", &MyClass::incWidth, GMetaPolicyCopyAllConstReference()) // reflect a method with policy
<{/code}>

<p>
<{autobr}>
	._method takes two or three parameters.
	The first parameter is the name. The named is used to find the meta data later.
	The second parameter is method address.
	The third parameter is optional. It's the policy.
<{/autobr}>
</p>


<{/sgroup}>



<{sh}> Reflect constructor
<{sgroup indent="1"}>

<{sh}> What's constructor
<{sc}>
	<p>
<{autobr}>
	A constructor is a C++ class constructor.
	It can take any parameters, same as method.
<{/autobr}>
	</p>

<{code}>
	GDefineMetaClass<MyClass>
		::define("MyClass")

		._constructor<void * ()>()
		._constructor<void * (int)>()
		._constructor<void * (int, const std::string &)>(GMetaPolicyCopyAllConstReference())
<{/code}>

<p>
<{autobr}>
	._constructor is a template function.
	It accepts one template parameter, and one optional policy function parameter.
	The template parameter is the function type. The function type must always return void *.
<{/autobr}>
</p>


<{/sgroup}>




<{sh}> Reflect operator
<{sgroup indent="1"}>

<{sh}> What's operator
<{sc}>
	<p>
<{autobr}>
	An operator is a C++ class operator that be overloaded.
	It can take any parameters, same as method.
<{/autobr}>
	</p>

<{code}>
	GDefineMetaClass<MyClass>
		::define("MyClass")

		._operator<MyClass (const GMetaSelf &, int)>(mopHolder + mopHolder) // +
		._operator<MyClass (const GMetaSelf &, int)>(mopHolder - mopHolder) // -
<{/code}>

<p>
<{autobr}>
	_operator is a template function.
	It accepts one template parameter, one operator function parameter, and one optional policy function parameter.
	The template parameter is the operator function type.
	The first function parameter is the result to apply the same operator on mopHolder.
	For example, if it's operator +, then the parameter is (mopHolder + mopHolder)
	For most operators, it's quite intuitive.
	Here are some operators that are not that intuitive:
	Type conversion, such like "int()", etc. The parameter is mopHolder().
	Functor, such like "void (int)". The parameter is mopHolder(mopHolder);

	About GMetaSelf. GMetaSelf indicates that parameter is the object itself. So that parameter can be passed as both object reference and object pointer.
<{/autobr}>
</p>


<{/sgroup}>





<{sh}> Reflect annotation
<{sgroup indent="1"}>

<{sh}> What's annotation
<{sc}>
	<p>
<{autobr}>
	An annotation is a kind of special meta data that's added by programmer rather than code.
	All other non-annotation meta data, such as class, method, field, property, constructor, operator, can have annotations.
<{/autobr}>
	</p>

<{code}>
	GDefineMetaClass<MyClass>
		::define("MyClass")

		._annotation("attribute")
			._element("name", "What's my name") // element name, value is an Ansi string
			._element("cat", mcatClass) // element cat, value is int
			._element("dog", TestData(mcatClass, "A cute dog")) // element dog, value is TestData
		._annotation("style")
			._element("fit", L"fit me") // element fit, value is a Wide string.

		._method("incWidth", &MyClass::incWidth, GMetaPolicyCopyAllConstReference()) // reflect a method with policy
			._annotation("attr") // the method incWidth has an annotation
				._element("what", "ok")
<{/code}>

<p>
<{autobr}>
	_nnotation takes one parameter, the annotation name.
	To add elements, just call _element on the object. The first parameter is the value name, the second parameter is the value.
	
	In above code, the annotation "attribute" and "style" are added to the meta class, and the annotation "attr" is added to meta method "incWidth".
<{/autobr}>
</p>


<{/sgroup}>





<{sh}> Reflect enumerators
<{sgroup indent="1"}>

<{sh}> What's enumerator
<{sc}>
	<p>
<{autobr}>
<{/autobr}>
	</p>

<{code}>
	GDefineMetaClass<MyClass>
		::define("MyClass")

		._enum<MyClass::WindowStyle>("WindowStyle")
			._element("ws0", MyClass::ws0)
			._element("ws1", MyClass::ws1)
			._element("ws2", MyClass::ws2)
			._element("ws3", MyClass::ws3)
<{/code}>

<p>
<{autobr}>
<{/autobr}>
</p>

<{/sgroup}>





<{sh}> Reflect nested class
<{sgroup indent="1"}>

<{sh}> What's nested class
<{sc}>
<{code}>
	class MyClass {
	public:
		class InnerClass { // this is nested class
		};
	};
<{/code}>

<{sh}> Using function
<{sc}>
<{code}>
	GDefineMetaClass<MyClass>
		::define("MyClass")

		._class(
			GDefineMetaClass<MyClass::InnerClass>
				::create("InnerClass")
				._field("whatever", &MyClass::InnerClass::whatever)
		)
<{/code}>

<p>
<{autobr}>
<{/autobr}>
</p>


<{/sgroup}>


<{/sgroup}>



<{/autotoc}>


<{include name="cpgf-footer.inc" }>
