<{filename name=docs-cpgf-serialization-meta-archive-writer-reader }>

<{title}>Create archive reader/writer and meta reader writer <{/title}>

<h1>Create archive reader/writer and meta reader writer </h1>


<{autotoc}>

<{sgroup}>Architecture

<{sh}> Overview
<{sc}>

<{autobr}>

There are two core concepts in the serialization library, archive reader/writer and meta reader/writer.

<b>Archive reader/writer </b>
The interfaces IMetaArchiveReader and IMetaArchiveWriter are the archive reader and writer.
The archive reader and writer are the core interfaces in the serialization library.

The archive writer does:
<{/autobr}>
<{autoul}>
Parse meta data information in the object.
Write the basic field values (fundamental, string, null pointer) to meta writer.
Write the class informations to meta writer.
Track pointers to serialize one object that's pointed by multiple pointers only once.
Create and use customized serializers for customized data type, such as std::string, C++ array.
<{/autoul}>

<{autobr}>
The archive reader does:
<{/autobr}>
<{autoul}>
Parse meta data information in the object.
Allocate memory for object field, if the field is pointer with value NULL.
Read the basic field values (fundamental, string, null pointer) from meta reader.
Read the class informations from meta reader.
Track pointers to deserialize one object that's pointed by multiple pointers only once.
Create and use customized serializers for customized data type, such as std::string, C++ array.
<{/autoul}>


<{autobr}>
<b>Meta reader/writer </b>
The interfaces IMetaReader and IMetaWriter is the meta reader and writer.
The meta reader and writer is the bridge between archive reader/writer and permanent storage.
The meta reader and writer takes care of storage format.
So to support any new storage format, just implement new meta reader and writer and feed them to archive reader/writer.

The cpgf library has three built in storage formats:
Text stream -- use plain text stream as storage. See gmetatextstreamarchive.h
XML -- use XML as storage. cpgf uses RapidXML to manipulate XML. See gmetaxmlarchive.h
JSON -- use JSON as storage. cpgf uses Jsoncpp to manipulate JSON. See gmetatextstreamarchive.h

<{/autobr}>


<{sh}> Create archive reader and writer.
<{sc}>

<{autobr}>
To create the interface for archive reader and writer, call below factory functions.

<{piece}>
	IMetaArchiveReader * createMetaArchiveReader(IMetaService * service, IMetaReader * reader);
	IMetaArchiveWriter * createMetaArchiveWriter(IMetaService * service, IMetaWriter * writer);
<{/piece}>

How to get the meta reader and writer will be explained later.
The meta service, IMetaService * service, is the meta data center that the archivers use to find meta data information.
To get the service for global meta data, just call createDefaultMetaService(). It will return a IMetaService interface.

<{/autobr}>


<{sh}> Create meta reader and writer.
<{sc}>

<{autobr}>
<b>Create meta reader/writer for text stream storage </b>

<{piece}>
	IMetaWriter * createTextStreamMetaWriter(std::ostream & outputStream);
	IMetaReader * createTextStreamMetaReader(IMetaService * service, std::istream & inputStream);
<{/piece}>

Text stream reader and writer works on C++ stream.
Usually a stringstream is the best.

<{/autobr}>


<{autobr}>
<b>Create meta reader/writer for XML storage </b>

<{piece}>
	IMetaWriter * createXmlMetaWriter(const GMetaXmlArchive & xmlArchive);
	IMetaReader * createXmlMetaReader(IMetaService * service, const GMetaXmlArchive & xmlArchive);
<{/piece}>

XML reader and writer works on GMetaXmlArchive.
GMetaXmlArchive is a simple wrapper for RapidXML.
RapidXML is included in cpgf library.

Functions in GMetaXmlArchive

<{piece}>void load(const char * xmlContent) const; <{/piece}>
Load XML content.
xmlContent is a string with the XML content.
GMetaXmlArchive will copy xmlContent to internal buffer.
So xmlContent can be freed after this function.

<{piece}>void saveToStream(std::ostream & outputStream) const; <{/piece}>
Save the XML content to a stream.

<{piece}>void loadIntrusive(char * xmlContent) const; <{/piece}>
Load XML content.
xmlContent must be valid during the object life.
And the content in xmlContent will be destroyed by GMetaXmlArchive.
This function is an optimization version of load. It doesn't copy the xmlContent, and use xmlContent in place.

<{piece}>
	GScopedInterface<IMetaService> service(createDefaultMetaService());

	GMetaXmlArchive archive;
	GScopedInterface<IMetaWriter> writer(createXmlMetaWriter(archive));

	GScopedInterface<IMetaArchiveWriter> archiveWriter(createMetaArchiveWriter(service.get(), writer.get()));
	
	// here we can write object to archiveWriter.
	
	GScopedInterface<IMetaReader> reader(createXmlMetaReader(archive));

	GScopedInterface<IMetaArchiveReader> archiveReader(service.get(), reader.get());
	
	// here we can read object from archiveReader.
<{/piece}>

<{/autobr}>


<{autobr}>
<b>Create meta reader/writer for JSON storage </b>

<{piece}>
	IMetaWriter * createJsonMetaWriter(const GMetaJsonArchive & jsonArchive);
	IMetaReader * createJsonMetaReader(IMetaService * service, const GMetaJsonArchive & jsonArchive);
<{/piece}>

JSON reader and writer works on GMetaJsonArchive.
GMetaJsonArchive is a simple wrapper for JsonCPP library.
JsonCPP is included in cpgf library.

Functions in GMetaJsonArchive

<{piece}>void load(const char * jsonContent) const; <{/piece}>
Load JSON content.
jsonContent is a string with the JSON content.
GMetaJsonArchive will copy jsonContent to internal buffer.
So jsonContent can be freed after this function.

<{piece}>void saveToStream(std::ostream & outputStream) const; <{/piece}>
Save the JSON content to a stream.


<{/autobr}>




<{/sgroup}>

<{/autotoc}>



