<{filename name=docs-cpgf-serialization-meta-archive-writer-reader }>

<{title}>Architecture -- archive reader/writer and meta reader writer <{/title}>

<h1>Architecture -- archive reader/writer and meta reader writer </h1>


<{autotoc}>

<{sgroup}>Architecture

<{sh}> Overview
<{sc}>

<{autobr}>

There are two core concepts in the serialization library, archive reader/writer and meta reader/writer.

<b>Archive reader/writer </b>
The interfaces IMetaArchiveReader and IMetaArchiveWriter are the archive reader and writer.
The archive reader and writer are the core interfaces in the serialization library.

The archive writer does:
<{/autobr}>
<{autoul}>
Parse meta data information in the object.
Write the basic field values (fundamental, string, null pointer) to meta writer.
Write the class informations to meta writer.
Track pointers to serialize one object that's pointed by multiple pointers only once.
Create and use customized serializers for customized data type, such as std::string, C++ array.
<{/autoul}>

<{autobr}>
The archive reader does:
<{/autobr}>
<{autoul}>
Parse meta data information in the object.
Allocate memory for object field, if the field is pointer with value NULL.
Read the basic field values (fundamental, string, null pointer) from meta reader.
Read the class informations from meta reader.
Track pointers to deserialize one object that's pointed by multiple pointers only once.
Create and use customized serializers for customized data type, such as std::string, C++ array.
<{/autoul}>


<{autobr}>
<b>Meta reader/writer </b>
The interfaces IMetaReader and IMetaWriter are the meta reader and writer.
The meta reader and writer is the bridge between archive reader/writer and permanent storage.
The meta reader and writer takes care of storage format.
So to support any new storage format, just implement new meta reader and writer and feed them to archive reader/writer.

The cpgf library has three built in storage format:
Text stream -- use plain text stream as storage. See gmetatextstreamarchive.h
XML -- use XML as storage. cpgf uses RapidXML to manipulate XML. See gmetaxmlarchive.h
JSON -- use JSON as storage. cpgf uses Jsoncpp to manipulate JSON. See gmetatextstreamarchive.h

<{/autobr}>


<{sh}> Create archive reader and writer.
<{sc}>

<{autobr}>
To create the interface for archive reader and writer, call below factory functions.

<{/autobr}>

<{code}>
IMetaArchiveReader * createMetaArchiveReader(IMetaService * service, IMetaReader * reader);
IMetaArchiveWriter * createMetaArchiveWriter(IMetaService * service, IMetaWriter * writer);
<{/code}>

<{autobr}>
How to get the meta reader and writer will be explained later.
The meta service, IMetaService * service, is the meta data center that the archivers use to find meta data information.
To get the service for global meta data, just call createDefaultMetaService(). It will return a IMetaService interface.

<{/autobr}>


<{sh}> Create meta reader and writer.
<{sc}>

<{autobr}>
Create meta reader/writer for text stream storage

<{/autobr}>

<{code}>
template <template<typename T> class TypeMap>
IMetaWriter * createTextStreamMetaWriter(std::ostream & outputStream, int);
inline IMetaWriter * createTextStreamMetaWriter(std::ostream & outputStream);

template <template<typename T> class TypeMap>
IMetaReader * createTextStreamMetaReader(IMetaService * service, std::istream & inputStream, int);
inline IMetaReader * createTextStreamMetaReader(IMetaService * service, std::istream & inputStream);
<{/code}>

<{autobr}>
The template functions have a second parameter. It's not used, it's there only to distinguish from the non-template function.
The template functions have a template parameter, TypeMap. TypeMap gives the ability to map a fundamental type to another, such as map "int" to "long long". It gives the possibility to port between different platforms.
However, since it's text stream, usually you only need the non-template version.

<{/autobr}>



<{/sgroup}>

<{/autotoc}>



