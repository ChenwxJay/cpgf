<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title></title>
</head>
<body><div style="width:900px">



<h3>ABC</h3>



<a id="top"></a>


<p>
<b>
<a href="#linkid1">
<strong>Define meta classes</strong></a></b></p>
<div style="margin-left:0px">
<ul>
<li>
<a href="#linkid2">
<strong>Overview</strong></a></li>
<li>
<a href="#linkid3">
<strong>Define meta classes outside of the classes declaration.</strong></a></li>
<li>
<a href="#linkid4">
<strong>Add meta data to global scope</strong></a></li>
<li>
<a href="#linkid5">
<strong>Reflect templates</strong></a></li>
<li>
<a href="#linkid6">
<strong>Reflect classes inside of the classes declaration.</strong></a></li>
</ul>
</div>
<p>
<b>
<a href="#linkid7">
<strong>Build meta data</strong></a></b></p>
<div style="margin-left:0px">
<ul>
<li>
<a href="#linkid8">
<strong>Overview</strong></a></li>
</ul>
</div>
<div style="margin-left:0px">
<ul>
<li>
<a href="#linkid9">
<strong>Reflect field</strong></a></li>
</ul>
</div>
<p>
<b>
<a href="#linkid10">
<strong></strong></a></b></p>
<div style="margin-left:60px">
<ul>
<li>
<a href="#linkid11">
<strong>What's field</strong></a></li>
<li>
<a href="#linkid12">
<strong>Using function</strong></a></li>
<li>
<a href="#linkid13">
<strong>Using macro helper</strong></a></li>
</ul>
</div>
<div style="margin-left:0px">
<ul>
<li>
<a href="#linkid14">
<strong>Reflect property</strong></a></li>
</ul>
</div>
<p>
<b>
<a href="#linkid15">
<strong></strong></a></b></p>
<div style="margin-left:60px">
<ul>
<li>
<a href="#linkid16">
<strong>What's property</strong></a></li>
<li>
<a href="#linkid17">
<strong>Using function</strong></a></li>
<li>
<a href="#linkid18">
<strong>Using macro helper</strong></a></li>
</ul>
</div>
<div style="margin-left:0px">
<ul>
<li>
<a href="#linkid19">
<strong>Reflect method</strong></a></li>
</ul>
</div>
<p>
<b>
<a href="#linkid20">
<strong></strong></a></b></p>
<div style="margin-left:60px">
<ul>
<li>
<a href="#linkid21">
<strong>What's method</strong></a></li>
<li>
<a href="#linkid22">
<strong>Using function</strong></a></li>
<li>
<a href="#linkid23">
<strong>Using macro helper</strong></a></li>
</ul>
</div>
<div style="margin-left:0px">
<ul>
<li>
<a href="#linkid24">
<strong>Reflect constructor</strong></a></li>
</ul>
</div>
<p>
<b>
<a href="#linkid25">
<strong></strong></a></b></p>
<div style="margin-left:60px">
<ul>
<li>
<a href="#linkid26">
<strong>What's constructor</strong></a></li>
<li>
<a href="#linkid27">
<strong>Using function</strong></a></li>
<li>
<a href="#linkid28">
<strong>Using macro helper</strong></a></li>
</ul>
</div>


<p><a id="linkid1"></a></p>
<h3>Define meta classes</h3><p><a id="linkid2"></a></p>
<p>
<strong>Overview</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>	<p>
	Meta class represents a collection of meta information about a certain class.<br />
	All meta data, like meta fields, meta properties, meta methods, meta enumerators, meta operators, meta constructor, meta annotation, must be added to a meta class.<br />
	For global fields and methods, they must be added to the global meta class (get via function getGlobalMetaClass).<br />
	In other words, Reflex is class based reflection system.<br />
<br />
	<b>Buiding meta data using function and macro helpers</b><br />
	Most meta data can be built in two ways,<br />
	Using function -- give you best control over the data type, name, etc. All reflex functions are prefixed with &quot;reflect&quot;. For instance, reflectField.<br />
	Using macro helper -- shortcut macro to save typing. All reflex macros start with GMETA_. For instance, GMETA_FIELD.<br />
	</p>

<p><a id="linkid3"></a></p>
<p>
<strong>Define meta classes outside of the classes declaration.</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>	Assume we want to define meta classes for below classes

<pre>    class Animal
    {
    };

    class Cat : public Animal
    {
    };
</pre>
	<p>Now let's build meta class for Animal.</p>

<pre>    GMETA_DEFINE_CLASS(Animal, Animal, &quot;Animal&quot;)
    {
    	// add any meta data here to reflect fields, methods, etc.
    }
</pre>
	<p>
	Use macro GMETA_DEFINE_CLASS to define a meta class.
	GMETA_DEFINE_CLASS accepts three primary parameters, plus arbitrary number of varadic parameters.
	</p>
	<p><i>The first parameter, here is Animal</i>, is the class type. It can have any scope prefix, such as MyNameSpace::Animal.</p>
	<p><i>The second parameter, here is Animal again</i>, is the class type alias. It can be any legal C++ symbol, as long as it's unique in the program. It can't have any scrop prefix. That's to say, it can't contain any '::'.</p>
	<p><i>The third parameter, here is &quot;Animal&quot;</i>, is the name of the meta class. It can be any string, such as &quot;Meta::WhatNameSpace::Animal&quot;, but highly recommand that only C++ symbol and ':' or '.' be used. It must be unique in the meta system. It's the key to find the meta class.</p>
	
	<p>Now let's build meta class for Cat.</p>

<pre>    GMETA_DEFINE_CLASS(Cat, Cat, &quot;Cat&quot;, Animal)
    {
    	// add any meta data here to reflect fields, methods, etc.

    	reflectField(&quot;eyes&quot;, &amp;Cat::eyes);
    }
</pre>	<p>
	This time there is the fourth parameter, Animal, which is the base class, aka, super class.<br />
	Reflex supports multiple inheritance. If Cat is also dervied from Biological, just add Biological to GMETA_DEFINE_CLASS.<br />
	<br />
	The base classes are not necessary reflected. When a non-reflected base class is retrieving for meta class by calling GMetaClass::getBaseClass, it always return NULL. However, calling GMetaClass::getBaseCount to get base class count will include all non-reflected base classes.<br />
	</p>



<p><a id="linkid4"></a></p>
<p>
<strong>Add meta data to global scope</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><pre>    GMETA_DEFINE_GLOBAL()
    {
    	// add any meta data here to reflect fields, methods, etc.

    	reflectField(&quot;catCount&quot;, &amp;catCount);
    }
</pre>
	Macro &quot;GMETA_DEFINE_GLOBAL&quot; indicates that any reflection between the curve brackets are reflected to global scope.<br />
	The global scoped is treated as a meta class, but it contains all global meta data for globa variables, methods, classes, etc.<br />
<br />
	When any meta class is defined by GMETA_DEFINE_CLASS, it's add to global scope automatically.<br />


<p><a id="linkid5"></a></p>
<p>
<strong>Reflect templates</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>

<p><a id="linkid6"></a></p>
<p>
<strong>Reflect classes inside of the classes declaration.</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>



<p><a id="linkid7"></a></p>
<h3>Build meta data</h3><p><a id="linkid8"></a></p>
<p>
<strong>Overview</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>	<p>
	All meta data must be put into some meta class definition blocks.<br />
	</p>




<p><a id="linkid9"></a></p>
<p>
<strong>Reflect field</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><p><a id="linkid10"></a></p>
<h3></h3><p><a id="linkid11"></a></p>
<p>
<strong>What's field</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>	<p>
	A field is either a member data or a global variable.<br />
	Getting and setting a field will be applied directly to the field without any setter or getter function.<br />
	To use setter and getter functions, use Property.<br />
	</p>

<p><a id="linkid12"></a></p>
<p>
<strong>Using function</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><pre>    class TestObject
    {
    private:
    	int width;
    	std::string name;
    	TestData data;

    	GMETA_FRIEND(TestObject);
    }

    GMETA_DEFINE_CLASS(blah blah)
    {
    	reflectField(&quot;width&quot;, &amp;TestObject::width);
    	reflectField(&quot;data&quot;, &amp;TestObject::data, GMetaPolicyNoncopyable());
    }
</pre>
<p>
	reflectField takes two or three parameters.<br />
	The first parameter is the name. The named is used to find the meta data later.<br />
	The second parameter is the field address.<br />
	The third parameter is optional. It's the policy.<br />
<br />
	GMETA_FRIEND is used to make the reflection friend to TestObject so it can access private member in TestObject.<br />
	If the member are public, no need GMETA_FRIEND.<br />
}&gt;
</p>

<p><a id="linkid13"></a></p>
<p>
<strong>Using macro helper</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><pre>    class TestObject
    {
    private:
    	int width;
    	std::string name;
    	TestData data;

    	GMETA_FRIEND(TestObject);
    }

    GMETA_DEFINE_CLASS(blah blah)
    {
    	GMETA_FIELD(width);
    }
</pre>
<p>
	GMETA_FIELD takes only one parameter.<br />
	The macro will use the parameter as the name and address.<br />
	Policy can't be passed in to the macro.<br />
}&gt;
</p>




<p><a id="linkid14"></a></p>
<p>
<strong>Reflect property</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><p><a id="linkid15"></a></p>
<h3></h3><p><a id="linkid16"></a></p>
<p>
<strong>What's property</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>	<p>
	A property is just a member data or a global variable, but can be accessed with or without getter or setter functions.<br />
	</p>

<p><a id="linkid17"></a></p>
<p>
<strong>Using function</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><pre>    class TestObject
    {
    public:
    	int getWidth() const;
    	void setWidth(int width);
    
    	const std::string &amp; getName() const;
    
    public:
    	int height;

    private:
    	int width;
    	std::string name;
    }

    GMETA_DEFINE_CLASS(blah blah)
    {
    	reflectProperty(&quot;name&quot;, &amp;TestObject::getName, 0); // #1
    	reflectProperty(&quot;width&quot;, &amp;TestObject::getWidth, &amp;TestObject::setWidth); // #2
    	reflectProperty(&quot;height&quot;, &amp;height, &amp;height, GMetaPolicyNoncopyable()); // #3
    }
</pre>
<p>
	reflectProperty takes three or four parameters.<br />
	The first parameter is the name. The named is used to find the meta data later.<br />
	The second parameter is getter address.<br />
	The third parameter is setter address.<br />
	The fourth parameter is optional. It's the policy.<br />
<br />
	Here &quot;getter&quot; and &quot;setter&quot; are not necessary functions, they can be the data address directly.<br />
}&gt;
</p>

<p><a id="linkid18"></a></p>
<p>
<strong>Using macro helper</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><pre>    class TestObject
    {
    public:
    	int getWidth() const;
    	void setWidth(int width);
    
    	SomeData &amp; getData() const;
    
    public:
    	int height;
    	SomeData data;

    private:
    	int width;
    }

    GMETA_DEFINE_CLASS(blah blah)
    {
    	GMETA_PROPERTY(width, getWidth, setWidth);
    	GMETA_PROPERTY(data, getData, data);
    }
</pre>
<p>
	GMETA_PROPERTY takes three parameter. Name, getter, then setter.<br />
	Policy can't be passed in to the macro.<br />
}&gt;
</p>




<p><a id="linkid19"></a></p>
<p>
<strong>Reflect method</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><p><a id="linkid20"></a></p>
<h3></h3><p><a id="linkid21"></a></p>
<p>
<strong>What's method</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>	<p>
	A method is a function.<br />
	It can take any parameters. If any parameter is an object, that object is not necessary to be reflected.<br />
	It can be any function, such as member function, virtual function, static member function, global function.<br />
	It can also has any calling convention, such as cdecl, stdcall, fastcall.<br />
	For member function, it can be const, volatile, and const volatile.<br />
	</p>

<p><a id="linkid22"></a></p>
<p>
<strong>Using function</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><pre>    class TestObject
    {
    public:
    	int getWidth() const;
    }

    GMETA_DEFINE_CLASS(blah blah)
    {
    	reflectMethod(&quot;getWidth&quot;, &amp;TestObject::getWidth);
    }
</pre>
<p>
	reflectMethod takes two or three parameters.<br />
	The first parameter is the name. The named is used to find the meta data later.<br />
	The second parameter is method address.<br />
	The third parameter is optional. It's the policy.<br />
</p>

<p><a id="linkid23"></a></p>
<p>
<strong>Using macro helper</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><pre>    class TestObject
    {
    public:
    	int getWidth() const;
    }

    GMETA_DEFINE_CLASS(blah blah)
    {
    	GMETA_METHOD(getWidth);
    }
</pre>
<p>
	GMETA_METHOD takes one parameter, the name.<br />
	Policy can't be passed in to the macro.<br />
</p>




<p><a id="linkid24"></a></p>
<p>
<strong>Reflect constructor</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><p><a id="linkid25"></a></p>
<h3></h3><p><a id="linkid26"></a></p>
<p>
<strong>What's constructor</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p>	<p>
	A constructor is a C++ class constructor.<br />
	It can take any parameters, same as method.<br />
	</p>

<p><a id="linkid27"></a></p>
<p>
<strong>Using function</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><pre>    class TestObject
    {
    public:
    	TestObject();
    	TestObject(int width);
    	TestObject(int width, const std::string &amp; name);
    	TestObject(int width, const std::string &amp; name, const TestData &amp; data);
    }

    GMETA_DEFINE_CLASS(blah blah)
    {
    	reflectConstructor&lt;void * ()&gt;();
    	reflectConstructor&lt;void * (int)&gt;();
    	reflectConstructor&lt;void * (int, const std::string &amp;)&gt;();
    	reflectConstructor&lt;void * (int, const std::string &amp;, const TestData &amp;)&gt;();
    }
</pre>
<p>
	reflectConstructor is a template function.<br />
	It accepts one template parameter, and one optional policy function parameter.<br />
	The template parameter is the function type. The function type must always return void *.<br />
</p>

<p><a id="linkid28"></a></p>
<p>
<strong>Using macro helper</strong><span style="margin-left:100px;font-size:small"><a href="#top">back top</a></span></p><p>
	No macro helper available for constructor.<br />
</p>













</div></body></html>